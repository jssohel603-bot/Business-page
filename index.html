<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Road Rush — Avoid the Buses</title>
<style>
  :root{--bg:#0b1220;--road:#2b2b2b;--side:#1b1f2a;--accent:#0ea5a4}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,#071428,#0b1830);color:#e6eef6;display:flex;align-items:flex-start;justify-content:center;padding:18px}
  .wrap{width:920px;max-width:96vw;padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  h1{margin:0 0 6px;font-size:20px}
  p.small{margin:0 0 12px;color:#cbd5e1}
  #game{display:block;width:100%;border-radius:10px;background:var(--road);touch-action:none}
  .hud{display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap}
  .panel{background:rgba(255,255,255,0.03);padding:10px;border-radius:8px;color:#e6eef6;min-width:110px;text-align:center}
  button{background:var(--accent);border:none;color:#022; padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:700}
  .hint{color:#c7f9f2;font-weight:600}
  @media(max-width:520px){.wrap{padding:12px}}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Road Rush — বাস এড়িয়ে বেঁচে যাও!</h1>
    <p class="small">Arrow / WASD দিয়ে চলুন, মোবাইলে টাচ দিয়ে বাম/ডান সোয়াইপ করুন। যতক্ষণ বেঁচে থাকবেন স্কোর বাড়বে। চাপুন Restart করে আবার খেলুন।</p>

    <canvas id="game" width="900" height="500"></canvas>

    <div class="hud">
      <div class="panel"><div>Score</div><div id="score" style="font-size:20px;font-weight:700">0</div><small>টিকে থাকার সময়</small></div>
      <div class="panel"><div>Speed</div><div id="speed" style="font-size:20px;font-weight:700">1</div><small>গেইম গতি</small></div>
      <div style="margin-left:auto"><button id="restart">Restart</button></div>
    </div>
    <div style="margin-top:8px;color:#cbd5e1">টিপ: স্কোর বাড়লে বাস বেশি দ্রুত আসবে — সাবধানে চলুন!</div>
  </div>

<script>
/* Road Rush — Avoid the Buses
   Single file: save as index.html and open in browser.
   Controls: Left/Right arrow or A/D. Mobile: swipe left/right.
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// Road configuration
const road = { x: W*0.12, w: W*0.76, left: W*0.12, right: W*0.12 + W*0.76 };
const laneCount = 3;
const laneWidth = road.w / laneCount;

// Player car
const player = {
  lane: 1, // 0..laneCount-1 (center start)
  x: 0,
  y: H - 110,
  w: Math.min(68, laneWidth*0.7),
  h: 100,
  color: '#1e90ff'
};

// Obstacles (buses)
let obstacles = []; // each: {lane, y, w,h, speed, type}
let spawnTimer = 0;
let spawnInterval = 1200; // ms initial
let gameSpeed = 1; // increases over time
let score = 0;
let running = true;
let lastTime = performance.now();

// UI
const uiScore = document.getElementById('score');
const uiSpeed = document.getElementById('speed');
const restartBtn = document.getElementById('restart');
restartBtn.addEventListener('click', initGame);

// helper: lane x center
function laneCenter(l){
  return road.left + laneWidth*l + laneWidth/2;
}

function initGame(){
  obstacles = [];
  spawnTimer = 0;
  spawnInterval = 1200;
  gameSpeed = 1;
  score = 0;
  running = true;
  player.lane = 1;
  player.x = laneCenter(player.lane);
  player.y = H - 110;
  uiScore.textContent = score;
  uiSpeed.textContent = gameSpeed.toFixed(1);
  lastTime = performance.now();
}
initGame();

// spawn obstacle
function spawnObstacle(){
  // choose random lane, sometimes make double-wide bus spanning 2 lanes
  const isWide = Math.random() < 0.14; // 14% chance wide bus
  let lane = Math.floor(Math.random()*laneCount);
  if (isWide && lane === laneCount-1) lane = laneCount-2;
  const w = isWide ? laneWidth*2*0.92 : laneWidth*0.92;
  const h = isWide ? 120 : 100;
  obstacles.push({
    lane: lane,
    x: isWide ? laneCenter(lane) + laneWidth/2 : laneCenter(lane),
    y: -h - 20,
    w: w,
    h: h,
    speed: 2 + gameSpeed*0.6 + Math.random()*1.2,
    color: '#c2410c', // bus color
    wide: isWide
  });
}

// update physics
function update(dt){
  if (!running) return;

  // increase difficulty slowly
  score += dt * 0.01 * gameSpeed; // score grows by time * speed
  // every 7 seconds increase speed a little
  if (Math.floor(score) % 70 === 0 && Math.floor(score) !== 0) {
    // small bump handled later to avoid spamming; we'll ramp via gameSpeed based on time
  }

  // spawn logic
  spawnTimer += dt;
  if (spawnTimer >= spawnInterval){
    spawnTimer = 0;
    spawnObstacle();
    // gradually reduce spawn interval but clamp
    spawnInterval = Math.max(520, spawnInterval - 20 - gameSpeed*6);
  }

  // increase global speed slowly
  gameSpeed += dt * 0.00006; // very slow ramp
  // update obstacles
  for (let i = obstacles.length-1; i >= 0; i--){
    const ob = obstacles[i];
    ob.y += ob.speed * (1 + gameSpeed*0.12) * (dt/16);
    // if off screen remove
    if (ob.y > H + 120) obstacles.splice(i,1);
  }

  // Collision check between player rect and obstacle rect
  // compute player rectangle
  player.x = laneCenter(player.lane);
  const px = player.x - player.w/2;
  const py = player.y - player.h/2;
  const pw = player.w;
  const ph = player.h;

  for (let ob of obstacles){
    const ox = ob.x - ob.w/2;
    const oy = ob.y - ob.h/2;
    const ow = ob.w;
    const oh = ob.h;
    if (rectIntersect(px,py,pw,ph, ox,oy,ow,oh)){
      // collision -> game over
      running = false;
      setTimeout(()=>{ /* nothing extra here */ }, 50);
      break;
    }
  }

  uiScore.textContent = Math.floor(score);
  uiSpeed.textContent = (1 + Math.floor(gameSpeed*10)/10).toFixed(1);
}

// rectangle intersection
function rectIntersect(x1,y1,w1,h1,x2,y2,w2,h2){
  return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h2 < y1);
}

// draw
function drawRoad(){
  // side gutters
  ctx.fillStyle = '#0f1724';
  ctx.fillRect(0,0,W,H);
  // road
  ctx.fillStyle = '#2b2b2b';
  ctx.fillRect(road.left, 0, road.w, H);
  // lane markings
  ctx.strokeStyle = '#e6e6e6';
  ctx.lineWidth = 3;
  ctx.setLineDash([40,28]);
  for (let i=1;i<laneCount;i++){
    const x = road.left + laneWidth * i;
    ctx.beginPath();
    ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  ctx.setLineDash([]);
  // side stripes
  ctx.fillStyle = '#ffffff33';
  ctx.fillRect(road.left-8,0,8,H);
  ctx.fillRect(road.left+road.w,0,8,H);
}

function drawPlayer(){
  const cx = player.x;
  const cy = player.y;
  const w = player.w, h = player.h;
  // car shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(cx - w/2 + 6, cy - h/2 + h - 8, w - 6, 8);
  // body
  roundRect(ctx, cx - w/2, cy - h/2, w, h, 10, player.color);
  // windows
  ctx.fillStyle = '#a5f3fc';
  ctx.fillRect(cx - w/2 + 8, cy - h/2 + 10, w - 16, 28);
  // wheels
  ctx.fillStyle = '#111';
  ctx.fillRect(cx - w/2 + 8, cy + h/2 - 10, 14, 8);
  ctx.fillRect(cx + w/2 - 22, cy + h/2 - 10, 14, 8);
}

function drawObstacles(){
  for (let ob of obstacles){
    const cx = ob.x, cy = ob.y, w = ob.w, h = ob.h;
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(cx - w/2 + 8, cy - h/2 + h - 10, w - 10, 10);
    // body
    roundRect(ctx, cx - w/2, cy - h/2, w, h, 8, ob.color);
    // windows (bus style)
    ctx.fillStyle = '#fff3';
    const windows = ob.wide ? 4 : 3;
    const margin = 12;
    const winW = (w - margin*2) / windows - 8;
    for (let i=0;i<windows;i++){
      const wx = cx - w/2 + margin + i*(winW + 8);
      const wy = cy - h/2 + 18;
      ctx.fillRect(wx, wy, winW, 18);
    }
    // wheels
    ctx.fillStyle = '#111';
    ctx.fillRect(cx - w/2 + 12, cy + h/2 - 12, 16, 10);
    ctx.fillRect(cx + w/2 - 28, cy + h/2 - 12, 16, 10);
  }
}

function roundRect(ctx, x, y, w, h, r, color){
  if (color) ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  ctx.fill();
}

function draw(){
  ctx.clearRect(0,0,W,H);
  drawRoad();
  drawObstacles();
  drawPlayer();

  // if game over show overlay
  if (!running){
    ctx.fillStyle = 'rgba(2,6,23,0.6)';
    ctx.fillRect(W/2 - 220, H/2 - 70, 440, 140);
    ctx.fillStyle = '#fff';
    ctx.font = '26px Inter, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', W/2, H/2 - 12);
    ctx.font = '18px Inter, Arial';
    ctx.fillText(`Final Score: ${Math.floor(score)}`, W/2, H/2 + 14);
    ctx.textAlign = 'start';
  }
}

// main loop
function loop(now){
  const dt = now - lastTime;
  lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// keyboard controls
window.addEventListener('keydown', (e)=>{
  if (!running && (e.key === 'Enter' || e.key === ' ')) { initGame(); return; }
  switch(e.key){
    case 'ArrowLeft': case 'a': case 'A': moveLeft(); break;
    case 'ArrowRight': case 'd': case 'D': moveRight(); break;
  }
});

// simple mobile swipe left/right
let touchStart = null;
canvas.addEventListener('touchstart', (e)=>{
  if (e.touches && e.touches.length === 1){
    const t = e.touches[0];
    touchStart = {x: t.clientX, y: t.clientY, time: Date.now()};
  }
}, {passive:true});
canvas.addEventListener('touchend', (e)=>{
  if (!touchStart) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStart.x;
  const dy = t.clientY - touchStart.y;
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 20){
    if (dx > 0) moveRight(); else moveLeft();
  } else {
    // short tap -> maybe accelerate (not implemented)
  }
  touchStart = null;
}, {passive:true});

// simple left/right functions
function moveLeft(){
  if (!running) return;
  player.lane = Math.max(0, player.lane - 1);
}
function moveRight(){
  if (!running) return;
  player.lane = Math.min(laneCount-1, player.lane + 1);
}

// responsive visuals (style only)
function fitCanvas(){
  const parentW = Math.min(900, Math.max(320, window.innerWidth - 40));
  canvas.style.width = parentW + 'px';
  canvas.style.height = (parentW * (H / W)) + 'px';
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

</script>
</body>
</html>
